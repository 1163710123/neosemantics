[[Inference]]
== Inferencing/Reasoning

something here

=== Class hierarchies

When modelling a hierarchy of categories we'll typically find categories represented by nodes and
related nodes connected through `SUBCAT_OF` or `NARROWER_THAN` relationships (or whatever your
choice of name will be).

Here's a sample categroy from http://id.loc.gov/authorities/subjects.html[the Library of Congress Subject Headings]:

[source,Cypher]
----
CREATE (c:LCSHTopic { authoritativeLabel: "Crystallography", dbLabel: "Crystallography", identifier: "sh 85034498" })
CREATE (po:LCSHTopic { authoritativeLabel: "Physical optics", dbLabel: "PhysicalOptics", identifier: "sh 85095187" })
CREATE (s:LCSHTopic { authoritativeLabel: "Solids", dbLabel: "Solids", identifier: "sh 85124647" })
CREATE (c)<-[:NARROWER_THAN]-(:LCSHTopic { authoritativeLabel: "Crystal optics", dbLabel: "CrystalOptics", identifier: "sh 85034488" })-[:NARROWER_THAN]->(po)
CREATE (c)<-[:NARROWER_THAN]-(:LCSHTopic { authoritativeLabel: "Crystals", dbLabel: "Crystals", identifier: "sh 85034503" })-[:NARROWER_THAN]->(s)
CREATE (c)<-[:NARROWER_THAN]-(:LCSHTopic { authoritativeLabel: "Dimorphism (Crystallography)", dbLabel: "DimorphismCrystallography", identifier: "sh 2007001101" })
CREATE (c)<-[:NARROWER_THAN]-(:LCSHTopic { authoritativeLabel: "Isomorphism (Crystallography)", dbLabel: "IsomorphismCrystallography", identifier: "sh 85068653" })
----

In this example we use LCSHTopic to label the categories and the `NARROWER_THAN` to link them in a
hierarchy that as we can see in this fragment does not necessarily need to be a tree (it the general
case it will be a graph).

image::crystallography-hierarchy.png[Topic hierarchy from the LCSH]

Now when it comes to use the categories we have defined to tag individuals we have two main options:

* We can link nodes representing individuals to the category (or categories) they belong to using
a `TYPE` or `IN_CATEGORY` (or again whatever your preferred name for that relationship).
* We can also use labels, and tag a node representing an individual with the category it belongs to.
While this approach is preferable in many cases, it will be harder to navigate to nodes with related
labels (by related in this case I mean super or sublabels).

The following methods will help you leveraging explicit class hierarchies in your graph to run
inferences whatever the modeling approach you follow from the ones described before.

==== semantics.inference.nodesInCategory

Let's look at the first way of annotating individuals. This script creates a few of them and links them
to the categories defined before.

[source,Cypher]
----
MATCH (co:LCSHTopic { authoritativeLabel: "Crystal optics"})
MATCH (is:LCSHTopic { authoritativeLabel: "Isomorphism (Crystallography)"})
MATCH (cr:LCSHTopic { authoritativeLabel: "Crystals"})

CREATE (:Work { title: "Crystals and light", identifier: "2167673"})-[:HAS_SUBJECT]->(co)
CREATE (:Work { title: "Optical crystallography", identifier: "11916857"})-[:HAS_SUBJECT]->(co)

CREATE (:Work { title: "Isomorphism in minerals", identifier: "8096161"})-[:HAS_SUBJECT]->(is)

CREATE (:Work { title: "Crystals and life", identifier: "12873809"})-[:HAS_SUBJECT]->(cr)
CREATE (:Work { title: "Highlights in applied mineralogy", identifier: "20234576"})-[:HAS_SUBJECT]->(cr)
----

image::crystallography-with-instances[Topic hierarchy with instances]

With this dataset I may want to know which are the nodes in a particular category. The `nodesInCategory`
method can help:

[source,Cypher]
----
MATCH (cat:LCSHTopic { authoritativeLabel: "Crystallography"})
CALL semantics.inference.nodesInCategory(cat, { inCatRel: "HAS_SUBJECT", subCatRel: "NARROWER_THAN"}) yield node
return node.title as work
----

[source,Cypher]
----
╒══════════════════════════════════╕
│"work"                            │
╞══════════════════════════════════╡
│"Optical crystallography"         │
├──────────────────────────────────┤
│"Crystals and light"              │
├──────────────────────────────────┤
│"Isomorphism in minerals"         │
├──────────────────────────────────┤
│"Crystals and life"               │
├──────────────────────────────────┤
│"Highlights in applied mineralogy"│
└──────────────────────────────────┘
----

==== semantics.inference.inCategory(node, category, {})
something about this function


==== semantics.inference.nodesLabelled


[source,Cypher]
----
CREATE (:CrystalOptics { title: "Crystals and light", identifier: "2167673"})
CREATE (:CrystalOptics { title: "Optical crystallography", identifier: "11916857"})

CREATE (:IsomorphismCrystallography { title: "Isomorphism in minerals", identifier: "8096161"})

CREATE (:Crystals { title: "Crystals and life", identifier: "12873809"})
CREATE (:Crystals { title: "Highlights in applied mineralogy", identifier: "20234576"})
----


[source,Cypher]
----
call semantics.inference.nodesLabelled('Crystallography',  { catNameProp: "dbLabel", catLabel: "LCSHTopic", subCatRel: "NARROWER_THAN"})
----

==== semantics.inference.hasLabel(node,label,{})

function

=== Property hierarchies

We can use `rdfs:subPropertyOf` to create hierarchies of relationships, or in other words to state
that all resources connected by one relationship are also implicitly connected by any parent
relationship. If I state that `ACTED_IN` is a subproperty of `WORKED_IN`,
when I find in the graph that Keanu Reeves `ACTED_IN` The Matrix, I can safely derive the fact that he
also `WORKED_IN` that movie, even if there is not an explicit `WORKED_IN` relationship in the graph
between Keanu and The Matrix.
This is useful in situations where we want to be able to dynamically define relationships by composing
existing ones.

The `semantics.inference.getRels` stored procedure uses exactly these semantics to infer implicit
relationships between nodes in the graph.

==== semantics.inference.getRels

Let's take the movie database. Remember you can have it loaded in Neo4j by running `:play movies` and
following the instructions in the guide. Let's say we have http://jbarrasa.github.io/neosemantics/docs/rdf/movieDBRelHierarchy.ttl[a fragment of a movie ontology] that contains a definition
of a relationship hierarchy. It does it by defining a number of `rdfs:subPropertyOf` statements
between relationships.
For instance, it states that every `ACTED_IN` relationship is also a `WORKED_IN` one. This is
the triple in question:

[source,RDF]
----
...

neovoc:ACTED_IN a owl:ObjectProperty;
  rdfs:label "ACTED_IN";
  rdfs:subPropertyOf neovoc:WORKED_IN .

...
----

To see this inferencing procedure in action, we'll start by loading the ontology.
We can load it either using the `semantics.importOntology` or the `semantics.importRDF` methods
described in the <<Import>> section.

Let's say we

[source,Cypher]
----
CALL semantics.importOntology("file:///Users/jesusbarrasa/Workspaces/tmpnsmntx/neosemantics/docs/rdf/movieDBRelHierarchy.ttl", "Turtle")
----

[source,Cypher]
----
CALL semantics.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/NCBITaxon-subProps.rdf","RDF/XML", { handleVocabUris: "IGNORE" })
----

This should load a simple hierarchy of annotation properties like the one in this screen capture from the Neo4j browser.

onto load image
movieDB-PropertyHierarchy-OntoLoad

rdf load image
image::movieDB-PropertyHierarchy.png[property hierarchy in a possible Movie Database Ontology loaded into Neo4j]

We can now add some instance data manually with a cypher script like this one:

[source,Cypher]
----
match ... merge ...
----


[source,Cypher]
----
:param config: { relLabel: "owl__AnnotationProperty", relNameProp: "rdfs__label", subRelRel : "rdfs__subPropertyOf"}
----


IT DOES NOT NEED TO COME FROM AN ONTO, I CAN CREATE MY ONTO IN NEO4J

[source,Cypher]
----
match (indiv:Individual { uri: "http://individual/12345"})
call semantics.inference.getRels(indiv,"synonym_type_property",$config) yield rel, node
return indiv, rel, node
----

Now we can use the `semantics.inference.getRels`






Let's look at another example. The http://www.obofoundry.org/ontology/ncbitaxon.html[ncbitaxon ontology]
defines a number of `rdfs:subPropertyOf` relationships between annotation properties.
For instance, it states that every `acronym` is also a `synonym_type_property`. This is the triple in
question:

[source,RDF]
----
...

<owl:AnnotationProperty rdf:about="http://purl.obolibrary.org/obo/ncbitaxon#acronym">
    <rdfs:label rdf:datatype="http://www.w3.org/2001/XMLSchema#string">acronym</rdfs:label>
    <rdfs:subPropertyOf rdf:resource="http://www.geneontology.org/formats/oboInOwl#SynonymTypeProperty"/>
</owl:AnnotationProperty>

...
----

To see this inferencing procedure in action, let's start by loading the ontology. We can load it all from the link above but for this example we will only load the small fragment available http://jbarrasa.github.io/neosemantics/docs/rdf/NCBITaxon-subProps.rdf[here])

[source,Cypher]
----
CALL semantics.importRDF("http://jbarrasa.github.io/neosemantics/docs/rdf/NCBITaxon-subProps.rdf","RDF/XML", { handleVocabUris: "IGNORE" })
----

This should load a simple hierarchy of annotation properties like the one in this screen capture from the Neo4j browser.

image::movieDB-PropertyHierarchy.png[property hierarchy in a possible Movie Database Ontology loaded into Neo4j]

We can now add some instance data manually with a cypher script like this one:

[source,Cypher]
----
match ... merge ...
----


[source,Cypher]
----
:param config: { relLabel: "owl__AnnotationProperty", relNameProp: "rdfs__label", subRelRel : "rdfs__subPropertyOf"}
----


IT DOES NOT NEED TO COME FROM AN ONTO, I CAN CREATE MY ONTO IN NEO4J

[source,Cypher]
----
match (indiv:Individual { uri: "http://individual/12345"})
call semantics.inference.getRels(indiv,"synonym_type_property",$config) yield rel, node
return indiv, rel, node
----

Now we can use the `semantics.inference.getRels`

load the full onto (Started streaming 1 records after 296988 ms and completed after 296989 ms.)

╒═══════════════════╤═══════════════╤═══════════════╤══════════════════════════════════════════════════════════════════════╤═══════════╤═══════════════╕
│"terminationStatus"│"triplesLoaded"│"triplesParsed"│"namespaces"                                                          │"extraInfo"│"configSummary"│
╞═══════════════════╪═══════════════╪═══════════════╪══════════════════════════════════════════════════════════════════════╪═══════════╪═══════════════╡
│"OK"               │12581469       │12581469       │{"http://purl.org/dc/elements/1.1/":"dc","http://purl.org/dc/terms/":"│""         │{}             │
│                   │               │               │dct","http://www.w3.org/1999/02/22-rdf-syntax-ns#":"rdf","http://purl.│           │               │
│                   │               │               │obolibrary.org/obo/":"ns1","http://www.w3.org/2002/07/owl#":"owl","htt│           │               │
│                   │               │               │p://www.geneontology.org/formats/oboInOwl#":"ns0","http://www.w3.org/2│           │               │
│                   │               │               │004/02/skos/core#":"skos","http://schema.org/":"sch","http://www.w3.or│           │               │
│                   │               │               │g/ns/shacl#":"sh","http://www.w3.org/2000/01/rdf-schema#":"rdfs","http│           │               │
│                   │               │               │://purl.obolibrary.org/obo/ncbitaxon#":"ns2"}                         │           │               │
└───────────────────┴───────────────┴───────────────┴──────────────────────────────────────────────────────────────────────┴───────────┴───────────────┘



run it on a 35 level deep hierarchy...

MATCH path = (n:owl__Class)-[:rdfs__subClassOf*35..]->() RETURN path LIMIT 1



Import gene ontology (Started streaming 1 records after 10655 ms and completed after 10655 ms.)

CALL semantics.importOntology("http://purl.obolibrary.org/obo/go/snapshot/go.owl","RDF/XML", { classLabel : 'Class', objectPropertyLabel: 'Rel', dataTypePropertyLabel: 'Prop'})

╒═══════════════════╤═══════════════╤═══════════════╤════════════╤═══════════╤══════════════════════════════════════════════════════════════════════╕
│"terminationStatus"│"triplesLoaded"│"triplesParsed"│"namespaces"│"extraInfo"│"configSummary"                                                       │
╞═══════════════════╪═══════════════╪═══════════════╪════════════╪═══════════╪══════════════════════════════════════════════════════════════════════╡
│"OK"               │180079         │1440102        │null        │""         │{"dataTypePropertyLabelName":"Prop","classLabelName":"Class","objectPr│
│                   │               │               │            │           │opertyLabelName":"Rel"}                                               │
└───────────────────┴───────────────┴───────────────┴────────────┴───────────┴──────────────────────────────────────────────────────────────────────┘





...work in progress...

Prox

"semantics.inference.getRels"	"semantics.inference.getRels(node :: NODE?, rel :: STRING?, params = {} :: MAP?) :: (rel :: RELATIONSHIP?, node :: NODE?)"	"semantics.inference.getRels(node,'rel','>') - returns all outgoing relationships of type 'virtRel' or its subtypes along with the target nodes."	["reader", "editor", "publisher", "architect", "admin"]	"READ"

"semantics.inference.nodesInCategory"	"semantics.inference.nodesInCategory(category :: NODE?, params = {} :: MAP?) :: (node :: NODE?)"	"semantics.inference.nodesInCategory('category') - returns all nodes connected to Node 'catNode' or its subcategories."	["reader", "editor", "publisher", "architect", "admin"]	"READ"

"semantics.inference.nodesLabelled"	"semantics.inference.nodesLabelled(label :: STRING?, params = {} :: MAP?) :: (node :: NODE?)"	"semantics.inference.nodesLabelled('label') - returns all nodes with label 'label' or its sublabels."	["reader", "editor", "publisher", "architect", "admin"]	"READ"


UDFs

"semantics.inference.hasLabel"	"semantics.inference.hasLabel(node :: NODE?, label :: STRING?, params = {} :: MAP?) :: (BOOLEAN?)"	"semantics.inference.hasLabel(node,label,{}) - checks whether node is explicitly or implicitly labeled as 'label'."	["admin", "reader", "editor", "publisher", "architect"]

"semantics.inference.inCategory"	"semantics.inference.inCategory(node :: NODE?, category :: NODE?, params = {} :: MAP?) :: (BOOLEAN?)"	"semantics.inference.inCategory(node, category, {}) - checks whether node is explicitly or implicitly in a category."	["admin", "reader", "editor", "publisher", "architect"]


